import pandas as pd
import numpy

def quantile_criteria(ds,scale=5):
    '''
    returns booleans 
    '''
    # quantile detection
    q1=ds.quantile(0.25)
    q3=ds.quantile(0.75)
    max_outlier=q3+scale*(q3-q1)
    min_outlier=q1-scale*(q3-q1)
    return (ds>max_outlier)|(ds<min_outlier)


def mad_criteria(ds):
    '''
    Median absolute deviation
    '''
    mad=abs(ds["z"]-ds["z"].median()).median()
    return ds["z"]>mad
    
def detect_outliers(ds,scale=5.0):
    '''
    return boolean indices (True for detected points, False otherwise)
    '''
    bids=quantile_criteria(ds,scale)
    return bids

def estimate_zmag_open(df,dz,scale=5.0):
    '''
    may need to refine the estimation

    '''
    
    bcids=[k for k in dz.keys() if isinstance(k[0],int)]
    beads=list(set([i[0] for i in bcids]))
    ncycles=max([i[1] for i in bcids])+1
    zmag_op=pd.DataFrame(index=beads,columns=range(ncycles))
    det=detect_outliers(dz,scale=scale)
    peaks=(dz[det]>0)
    
    
    zmag_op=pd.DataFrame(index=beads,columns=range(ncycles))

    for k in bcids:
        zmag_op.loc[k[0],k[1]]=(df[("zmag",k[1])][peaks[k]]).median()
     
    '''
    # detection of zmag_op using maximal dz value
    idzopen=dz.idxmax(axis=0) # Xmas gift!
    for idx in idzopen.index:
        if isinstance(idx[0],int):
        zmag_op.loc[idx[0],idx[1]]=df[("zmag",idx[1])][idzopen[idx]]
    '''
    
    return zmag_op


def alt_estimate_zmag_open(df,dz,scale=5.0,reverse_time=False):
    '''
    alternative approach to estimate the zmag_open

    '''
    
    bcids=[k for k in dz.keys() if isinstance(k[0],int)]
    beads=list(set([i[0] for i in bcids]))
    ncycles=max([i[1] for i in bcids])+1
    zmag_op=pd.DataFrame(index=beads,columns=range(ncycles))

    det=detect_outliers(dz,scale=scale)
    '''
    if reverse_time:
        ids=dz[dz[det]>0].apply(lambda x:x.last_valid_index())    
    else:
        ids=dz[dz[det]>0].apply(lambda x:x.first_valid_index())

    '''
    
    ids=dz[dz[det]>0].apply(lambda x:x.last_valid_index())    
    for bcid in bcids:
        zmag_op.loc[bcid[0],bcid[1]]=df[("zmag",bcid[1])][ids[bcid]] if numpy.isfinite(ids[bcid]) else numpy.nan

    return zmag_op


def alt2_estimate_zmag_open(df,dz,scale=5.0):
    '''
    Second alternate estimation of zmag_open
    The goal is to better estimate the zmag_op
    need to add weight to each 
    '''
    
    bcids=[k for k in dz.keys() if isinstance(k[0],int)]
    beads=list(set([i[0] for i in bcids]))
    ncycles=max([i[1] for i in bcids])+1
    zmag_op=pd.DataFrame(index=beads,columns=range(ncycles))
    det=detect_outliers(dz,scale=scale)
    peaks=(dz[det]>0)
    
    
    zmag_op=pd.DataFrame(index=beads,columns=range(ncycles))

    for k in bcids:
        zmag_op.loc[k[0],k[1]]=(df[("zmag",k[1])][peaks[k]]).median()
     
    
    return zmag_op

def estimate_zmag_close(df,dz,scale=5.0,reverse_time=False):
    '''
    need to check whether the estimation is fine enough
    scale's value can be lower here than for estimate_zmag_open 
    '''
    bcids=[k for k in dz.keys() if isinstance(k[0],int)]
    beads=list(set([i[0] for i in bcids]))
    
    ncycles=max([i[1] for i in bcids])+1

    det=detect_outliers(dz,scale=scale)

    if reverse_time:
        ids=dz[dz[det]<0].apply(lambda x:x.last_valid_index())    
    else:
        ids=dz[dz[det]<0].apply(lambda x:x.first_valid_index())

    zmag_close=pd.DataFrame(index=beads,columns=range(ncycles))
    for bcid in bcids:
            zmag_close.loc[bcid[0],bcid[1]]=df[("zmag",bcid[1])][ids[bcid]] if numpy.isfinite(ids[bcid]) else numpy.nan
            
    return zmag_close

def sanitise_beads_collection(df,scale=5.0,min_corr=0.2,maxzmag_err=0.01):
    '''
    Implements a number of test performed on each bead and for each cycle.
    Should one bead fail a test at either cycle it is removed from the collection.
    
    Tests :
        *Can't use the zmax to estimate beads that don't open or not because of weird behaviour of some of the beads (see bead 0
        from /media/data/helicon/remi/2016-11-08/ramp_5HPs_mix.trk).
        *(1) The most reliable test found was to see if the bead "behaves" as expected, i.e. if there is some values of dz detected
        by function detect.
        *(2) z and zmag should be (more or less) correlated (corr>min_corr)
        *(3) estimation of zmag_op should be fine enough

    '''
    # first test on detection of outliers
    dz=df.rename_axis(lambda x:x-1)-df.rename_axis(lambda x:x+1)
    dz=dz.reindex(df.index)

    keys=[k for k in df.keys() if isinstance(k[0],int)]
    
    det=detect_outliers(dz,scale=scale)
    to_del=[k[0] for k in keys if det[k].sum()==0]
            
    # second test on the correlation between z and zmag
    corrs=df.corr()
    to_del+=[k[0] for k in keys if corrs[("zmag",k[1])][k]<min_corr]
    to_del=set(to_del)
    
    for d in to_del:
        for k in df.keys():
            if k[0]==d:
                df.pop(k)
                dz.pop(k)

    # third test on zmag estimation
    zmag_op=estimate_zmag_open(df,dz,scale=scale)
    stds=zmag_op.std(axis=1)
    zmag_op=zmag_op[stds<maxzmag_err]
    df=df[[c for c in df.columns if not isinstance(c[0],int) or c[0] in zmag_op.index]]
    dz=dz[df.columns]  
    
    return df,dz,zmag_op


def can_be_struture_event(dz,detected):
    '''
    args : dz and detected (output of detect_outliers(dz))
    '''
    # find when rezipping starts
    st_rezip=dz[dz[detected]<0].apply(lambda x: x.first_valid_index())
    # find when rezipping stops
    ed_rezip=dz[dz[detected]<0].apply(lambda x: x.last_valid_index())
    # create a map : 
    # If not detected by the sanitising algorithm, 
    # after z_closing (first dz[detected]>0, 
    # and before last dz[detected]<0
    canbe_se=~detected&dz.apply(lambda x:x.index>(st_rezip[x.name]))&dz.apply(lambda x:x.index<(ed_rezip[x.name]))

    return canbe_se

def find_attached_beads(df,scale=5.0,min_corr=0.2,maxzmag_err=0.01):
    '''
    uses the the sanitise_beads_collection and returns the indices of kept beads
    '''
    df=sanitise_beads_collection(df,scale=scale,min_corr=min_corr,maxzmag_err=maxzmag_err)[0]
    beadids=list(set([k[0] for k in df.keys() if isinstance(k[0],int)]))
    beadids.sort()
    return beadids

def find_fixed_beads(df):
    '''
    TO IMPLEMENT
    '''
    
    return

def find_untracked_beads(df):
    '''
    TO IMPLEMENT
    '''
    
    return

